// let arr = [31, 21, 1, 245, 22, 11, 456];
// // 取一个数作为基准，每次和基准数相比，小的放左边，大的放右边
// quickSort = (arr) => {
//   // 1、找基准数,毕竟和基准数作比较，分成左右两个数组（左边小于基准数，右边大于基准数）
//   let base_num = arr[0]; // 基准数
//   let left_arr = [];
//   let right_arr = [];
//   for (let i = 1; i < arr.length; i++) {
//     if (arr[i] < base_num) {
//       left_arr.push(arr[i]);
//     } else {
//       right_arr.push(arr[i]);
//     }
//   }
//   // 2、对左右数组进行快速排序
//   if (left_arr.length >= 2) {
//     left_arr = quickSort(left_arr);
//   }
//   if (right_arr.length >= 2) {
//     right_arr = quickSort(right_arr);
//   }

//   // 3、合并排序好之后的左数组、基准数和右数组
//   return left_arr.concat(base_num, right_arr);
// };
// let a = quickSort(arr);

// 需求：
/**
 * 1、输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树
 * 2、假设输入的前序遍历和中序遍历的结果都不含重复的数字
 * 3、例如输入前序遍历序列[1,2,4,7.3,5,6,8]和中序遍历序列[4,7,2,1,5,3,8,6]
 * 则重建二叉树并返回
 */
// 二叉树遍历规则
/**
 * 前序遍历序列：根左右：1,2,4,7.3,5,6,8
 * 中序遍历序列：左根右：4,7,2,1,5,3,8,6
 */
// 思路
/**
 * 1、找到根节点（前序序列的第一个元素为根节点）
 * 2、根据找到的根节点和中序序列，找到左右子树
 * 3、左子树和右子树进行1、2的递归操作
 *    根节点 为1
 *    左子树：
 *    左子树的前序序列：根左右：2,4,7
 *    左子树的中序序列：根左右：4,7,2
 *    右子树：
 *    右子树的前序序列：根左右：3,5,6,8
 *    右子树的中序序列：根左右：5,3,8,6
 */